import WS from 'isomorphic-ws';

import type { URLLike } from '@/types/primitive.types';

import type { JsonRpcResult } from './connection.types';

function sendAndAwaitOnce<T = any>(ws: WS, id: number, method: string, params: any[], timeoutMs: number): Promise<T> {
  // One message with expected response by specific id

  // Util function to safely stringify objects
  const safeStringify = (x: unknown) => {
    try {
      return JSON.stringify(x);
    } catch {
      return String(x);
    }
  };

  return new Promise<T>((resolve, reject) => {
    const payload = JSON.stringify({ jsonrpc: '2.0', id, method, params });

    // Handle connection errors
    const fail = (e: unknown) => {
      cleanup();
      reject(e instanceof Error ? e : new Error(String(e))); // Handle error
    };

    // Handle timeout
    const timer = setTimeout(() => {
      fail(new Error(`RPC timeout (ID: ${id}) after ${timeoutMs}ms`)); // timeout
    }, timeoutMs);

    const cleanup = () => {
      clearTimeout(timer);
      ws.removeEventListener('message', onMessage as any);
      ws.removeEventListener('error', onError as any);
      ws.removeEventListener('close', onClose as any);
    };

    // Event Handlers
    const onMessage = (msg: any) => {
      try {
        // Decode message data, parses JSON
        const raw = typeof msg.data === 'string' ? msg.data : msg.data?.toString?.();
        const data = JSON.parse(raw) as JsonRpcResult<T> & { id: number };

        // ignore other messages
        if (data?.id !== id) return;

        cleanup(); // Received response, remove handlers

        // Handle response
        if ('error' in data) {
          const { code, message, data: extra } = data.error;
          const tail = extra === undefined ? '' : ` data=${safeStringify(extra)}`;
          reject(new Error(`RPC error ${code}: ${message}${tail}`)); // RPC error
        } else resolve(data.result as T); // Ok result
      } catch (e) {
        fail(e); // Parsing error
      }
    };

    // Built-in error handler
    const onError = (e: any) => {
      fail(e?.error ?? e);
    };
    const onClose = () => {
      /* timeout/error will handle */
    }; // If connection is closed before onmessage, error is already generated by onerror/timeout/fail

    // Send request, built-in error handler
    ws.addEventListener('message', onMessage as any);
    ws.addEventListener('error', onError as any);
    ws.addEventListener('close', onClose as any);

    try {
      ws.send(payload);
    } catch (e) {
      fail(e); // Failed to send message
    }
  });
}

class BitsharesRPC {
  private nextId: number = 1; // Unique ID for each request within a transaction (resets per transaction)

  constructor(
    public readonly endpointURL: URLLike, // Example: 'wss://example.com/ws'
    private readonly defaultTimeoutMs: number = 10_000 // Default timeout in milliseconds
  ) { }

  /**
   * One "session" over **one** WS:
   * Login("", "") -> get apiId for namespace -> call method -> close socket.
   *
   * @param apiNamespace Bitshares API namespace: "database" | "history" | "network_broadcast".
   * @param method Target method to call.
   * @param params Parameters for the target method.
   * @param timeoutMs Timeout for the entire transaction.
   */
  async call<T = unknown>(
    apiNamespace: 'database' | 'history' | 'network_broadcast' | string,
    method: string,
    params: any[],
    timeoutMs: number = this.defaultTimeoutMs
  ): Promise<T> {
    const ws = new WS(this.endpointURL);
    this.nextId = 1; // ID resets after each transaction

    try {
      // Open connection
      await new Promise<void>((res, rej) => {
        const t = setTimeout(() => rej(new Error(`Connect timeout after ${timeoutMs}ms`)), timeoutMs);
        ws.onopen = () => {
          clearTimeout(t);
          res();
        };
        ws.onerror = (e: ErrorEvent) => {
          clearTimeout(t);
          rej((e as any)?.error ?? e);
        };
      });

      // 1. Login("", "") - ID: 1
      await sendAndAwaitOnce(ws as any, this.nextId++, 'call', [1, 'login', ['', '']], timeoutMs);

      // 2. Get apiId of the required namespace - ID: 2
      const apiId: number = await sendAndAwaitOnce(ws as any, this.nextId++, 'call', [1, apiNamespace, []], timeoutMs);

      // 3. Call the target method - ID: 3
      const result = await sendAndAwaitOnce<T>(ws as any, this.nextId++, 'call', [apiId, method, params], timeoutMs);

      return result; // Final result
    } finally {
      // ALWAYS close the socket after the transaction is complete
      try {
        ws.close();
      } catch { }
    }
  }
}

export { BitsharesRPC };
